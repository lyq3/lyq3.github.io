<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring in Anction:Spring AOP 小记]]></title>
    <url>%2F2018%2F04%2F29%2FSpringCloud%2FSpringCloud-core%2F</url>
    <content type="text"><![CDATA[微服务基础1、 微服务带来的挑战* 运维的新挑战 微服务会导致部署的程序增多，合理的编排很重要 * 接口的一致性 微服务虽然拆分了，但还是需要通过接口进行业务上的依赖，若接口改变了，需要提供方和调用方协调改动，不然会出现接口不一致问题。 * 分布式的复杂性 由于拆分各个微服务都是独立运行各自的进程中，可能分布在不同的服务器、不同的地域，它们只能通过网络通信来进行合作，所以要考虑很多因素，如：网络延迟、分布式事务、异步消息、session同步等问题。 2、智能端口与哑管道在单体应用中通过函数调用，在微服务中由于不在同一进程所以要通过网络调用，如果仅仅是改用RPC调用，会导致微服务之间产生繁琐的通信，使系统表现更为糟糕，所以需要更粗粒的的通信协议。 &gt; 在微服务中通常采用以下两种调用方式： * 使用HTTP 的RESTful API 或轻量级消息发送协议 * 通过在轻量级消息总线上传递消息，如：rabbitMQ 3、去中心化采用微服务后，各个组件通过RESTful 接口进行调用依赖，各个应用组件可以使用自己的数据库，可以使用不同的数据库（如MongoDB），而且不用局限于某一种技术，各个组件都可以选择合适的技术栈，避免出现“杀鸡用牛刀”的局面。 4、容错设计传统单体应用中，如果需要修改或增加一个功能则要将整个应用重新部署，如果某一组件出现问题就会出现一挂全挂的局面，而微服务架构中某一组件出现问题可以单独下线不影响其他功能使用。 5、为什么选用SpringCloud一句话：SpringCloud包含微服务的方方面面，大而全、成熟、省心、社区活跃、Spring和Netflix背书。 6、SpringCloud简介SpringCloud包含多个子项目，还会不断增加： * SpringCloud Config :配置中心，支持使用git存储配置文件，提高项目配置灵活性 * SpringCloud Netflix: 核心组件，对Netflix OSS开源套件进行组合，包含： 1. Eureka:注册中心，服务的发现与注册 2. Hystrix: 容错管理组件，提供降级熔断等保护机制 3. Ribbon： REST客户端调用组件，提供负载等功能 4. Feign: 基于 Ribbon： 和 Hystrix的声明式组件调用组件 5. Zuul: 网管组件，提供智能路由、访问过滤等功能 6. Archaius: 外部化配置组件 * SpringCloud Bus ： 事件、消息总线 * SpringCloud Cluster: 针对ZooKeeper、Redis、Consul的选举算法和通用状态模式的实现]]></content>
      <categories>
        <category>看书笔记</category>
        <category>SpringCloud微服务实战</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之泛型总结]]></title>
    <url>%2F2017%2F11%2F07%2FJavaCore%2Fjava_genericity%2F</url>
    <content type="text"><![CDATA[一、为什么使用泛型1.可读性好，一看泛型就知道里面装的什么类型的元素2.泛型只在编译前存在，编译后会将类型擦除并替换成其限定类型，编译后就是一个普通类。泛型可以在编译前规范代码，防止放入一些不合格的对象导致运行期报错，提高程序健壮性。3.使用泛型让程序更灵活，各类框架就大量使用泛型 个人理解：泛型可以大概分为两部分：定义泛型和使用泛型，大多数时候我们是在使用泛型，也就是用具体类型限制，比如：List《String》,而写一些通用工具或者框架的时候需要自己定义泛型类，泛型方法等提高程序的灵活性。 二、定义简单泛型类例如： 定义泛型类：12345678910public class Pair&lt;T&gt;&#123; private T first; private T second; public Pair()&#123;first = null;second = null&#125; public pair(T first, T second)&#123; this.first = first; this.second = second; &#125; //set get 略...&#125; 类型变量使用大写形式，且比较短，在java库中，E表示集合的元素类型，K和V分别表示Key和值，T表示任意值，也可以使用邻近的U和S 使用泛型：1Pair&lt;String&gt; 三、泛型方法例： 定义泛型方法12345public ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T... a)&#123; return a[a.length / 2]; &#125;&#125; 泛型的类型变量放在修饰符的后面（这里是public static） ，返回值的前面，泛型方法可以定义在可以定义在普通类中，也可以定义在泛型类中 使用泛型方法1String middle = ArrayAlg.&lt;String&gt;getMiddle("aaa","sss","sdsd"); 上面限制了是String，如果放入一个int类型的参数就会报错，大多数情况下《String》可以省略的，编译器会自己推导出限制类型；1ArrayAlg.getMiddle("aaa",123,"sdsd"); 上面这句代码不会报错，但是编译器推导的限制类型是String 和 Integer公共父类型，如果用String接收返回值会提示： 1Incompatible types. Required String but 'getMiddle' was inferred to T: Incompatible types: Serializable &amp; Comparable&lt;? extends Serializable &amp; Comparable&lt;?&gt;&gt; is not convertible to String 大概意思是可以赋值给Serializable 或 Comparable类型 四、类型变量的限定 我们在定义泛型的时候可以限定其范围：如：1public static &lt;T extends Comparable&gt; T min(T[] a)... 我们在使用时就只能使用实现了Comparable接口的类型来限制。 这里是接口但依然使用extends关键字，主要是为了表明是父子关系。不管是类还是接口泛型里都是使用extends 一个类型变量或通配符可以有多个限定如：1T extends Comparable &amp; Serializable 可以根据需要拥有多个接口超类型，但是限定中至多有一个类，而且这个类必须在列表的第一个 1T extends class &amp; interface &amp; interface &amp; interface //就像这样的格式，如果有类，放在第一个 五、类型擦除无论何时定义一个泛型类型，都自动提供一个原始类型，原始类型用第一个限定的类型变量来替换 T 是一个无限定的变量，所以会直接用Object替换，如 private T first 编译后变成 private Object first 如果是1&lt;T extends Comparable &amp; Serializable&gt; 则原始类型会用第一个（即Comparable）代替，private Comparable first; 在使用泛型的时候编译器会自动加入强制类型转换，转换成我们给定的类型 如：12Pair&lt;String&gt; b = ...String ru = b.getName(); 类型擦除后getName返回类型会用Object替换T，编译器会插入String强制类型转换 注意：要考虑类型擦除后带来的隐藏隐患 六、约束与局限性1、不能用基本类型实例化类型参数1如：Pair&lt;int&gt;不行，只能用Pair&lt;Integer&gt; 2、运行时类型查询只适用于原始类型12例如：if(a instanceof Pair&lt;String&gt;) //报错 ( Pair&lt;String&gt;) a //强转，报错 3、不能创建参数化类型的数组1Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10];//报错，声明不会报错，但初始化就会报错 4、不能实例化类型变量如：new T[] 5、不能构造泛型数组如：T[] 6、泛型类的静态上下文中类型变量无效如：private static T abc;//报错 7、不能抛出或捕获泛型类的实例如：12345try&#123;&#125;catch(T e)&#123;&#125; 不过，在异常规范中使用类型变量是允许的 123456789public static &lt;T extends Throwable&gt; void doWork(T t) thows T&#123;//ok try&#123; &#125;catch(Throwable realCause)&#123; t.initCause(realCause); throw t; &#125;&#125; 8、注意泛型的继承12 A extends BPair&lt;B&gt; 不是 Pair&lt;A&gt; 的子类，会类型擦除的 七、通配符类型能一定程度解决上面泛型不能继承的问题1Pair&lt;? extends B&gt; 如果调用上面方法的set方法会报错，不能设置值，因为不能确定是什么类型的值，可以get ? extends B 不能设置值，如果是集合（如List）就不能添加值。因为不能到是什么类型的值，但是能获取值，获取的值一定是B的子类，可以用B接收 ？ super B 不能获取值，能设置/添加值，因为一定是B的子类，不能获取值，如果获取出来用什么接收呢？因为类型不确定。 ？ 不能添加也不能获取，道理同上，但是能加入null，因为对象都能表示为null 八、反射和泛型 未完。。]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Java核心技术卷(第10版)</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性之Lambda表达式总结]]></title>
    <url>%2F2017%2F10%2F31%2FJavaCore%2FJava8_lambda%2F</url>
    <content type="text"><![CDATA[函数式接口Lambda不是所有方法都能使用的，得满足一定的条件，比如得满足函数式接口。 对于只有一个抽象方法的接口，需要这种借口的对象时，就可以提供一个Lambda表达式，这种接口称为函数式接口，也就是只有一个抽象方法的接口（不包括继承的） 函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个lambda表达式作为参数。从另一个方面说，一旦我们调用某方法，可以传入lambda表达式作为参数，则这个方法的参数类型，必定是一个函数式的接口，(这个类型可以使用@FunctionalInterface进行修饰，好处是，如果无意中增加了方法或者不符合lambda接口规范，编译器会提示错误，另外javadoc中会指出是一个函数式接口，推荐使用注解 从SAM原则上讲，这个接口中， 只能有一个函数需要被实现 ，但是也可以有如下例外: 1. 默认方法与静态方法并不影响函数式接口的契约，可以任意使用，即 函数式接口中可以有静态方法，一个或者多个静态方法不会影响SAM接口成为函数式接口，并且静态方法可以提供方法实现 可以由 default 修饰的默认方法方法，这个关键字是Java8中新增的，为的目的就是使得某一些接口，原则上只有一个方法被实现，但是由于历史原因，不得不加入一些方法来兼容整个JDK中的API，所以就需要使用default关键字来定义这样的方法 Lambda语法 一例胜千言 123456789101112131415 // =====Lambda //这里省略list的构造List&lt;String&gt; names = ...;Collections.sort(names, (o1, o2) -&gt; o1.compareTo(o2)); //===原始形态//这里省略list的构造List&lt;String&gt; names = ...;Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o1.compareTo(o2); &#125;&#125;); 完整一般语法：123456 (Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123; statment1; statment2; //............. return statmentM;&#125; 参数类型省略–绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型。这样lambda表达式就变成了： 123456(param1,param2, ..., paramN) -&gt; &#123; statment1; statment2; //............. return statmentM;&#125; 当lambda表达式的参数个数只有一个，可以省略小括号。lambda表达式简写为： 123456param1 -&gt; &#123; statment1; statment2; //............. return statmentM;&#125; 当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号。1param1 -&gt; statme 方法的引用个人理解：上面的Lambda有点像是实现匿名内部类的一个简化版本，我们需要传入代码以实现函数式接口内的那个抽象方法，方法引用有点像是引用其他已经实现好的方法。我们就不用再实现了（当然得看引用的方法满不满足需求） 方法引用：objectName::instanceMethod (对象.方法名)ClassName::staticMethod (类名.静态方法)ClassName::instanceMethod 前两种方式类似，等同于把lambda表达式的参数直接当成instanceMethod|staticMethod的参数来调用。比如System.out::println等同于x-&gt;System.out.println(x)；Math::max等同于(x, y)-&gt;Math.max(x,y)。 最后一种方式（类名+非静态方法），等同于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数。比如String::toLowerCase等同于x-&gt;x.toLowerCase()。 构造器引用构造器引用语法如下：构造器引用和方法引用有点类似，只不过方法名为new,如：ClassName::new，把lambda表达式的参数当成ClassName构造器的参数 。例如BigDecimal::new等同于x-&gt;new BigDecimal(x)。 可以用数组类型建立构造器引用：int[] :: new他有一个参数即数组长度等价于Lambda : x -&gt; new int[x] 变量的作用域Lambda表达式也可访问外部的变量(参考内部类) lambda表达式的三个重要组成部分： 输入参数 可执行语句 自由变量的值，这是指非参数而且不在代码中定义的变量 1234String[] array = &#123;"a", "b", "c"&#125;;for(Integer i : Lists.newArrayList(1,2,3))&#123; Stream.of(array).map(item -&gt; Strings.padEnd(item, i, '@')).forEach(System.out::println);&#125; 上面的这个例子中，map中的lambda表达式访问外部变量Integer i。 不过lambda表达式访问外部变量有一个非常重要的限制：变量不可变（java是值传递，也就是说基本类型值不能变，只是引用不可变，而不是真正的不可变)可以参考内部类引用外部变量也是必须用final声明，不过在Lambda中编译器会隐式的当做final处理，不加fina也可以 12345String[] array = &#123;"a", "b", "c"&#125;;for(int i = 1; i&lt;4; i++)&#123; Stream.of(array).map(item -&gt; Strings.padEnd(item, i, '@')).forEach(System.out::println);&#125; 上面这个要报错 Lambda中的this在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象。 处理（接收）Lambda表达式上面我们已经了解和使用了Lambda表达式，下面讨论下怎么接收处理Lambda表达式 使用Lambda的重点是延迟执行，像需要多次运行的场景就适合使用，jdk提供了很多常用的函数式接口，所以在自定义方法时可以使用这些函数式接口，不用自己再创建接口。还有一些基本类型的函数式接口，减少int double等的自动开装箱。]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Java核心技术卷(第10版)</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JAVA8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言学习之基础语法]]></title>
    <url>%2F2017%2F10%2F27%2FGoLang%2Fbase%2F</url>
    <content type="text"><![CDATA[包Go使用package来组织代码。每一个可独立运行的Go程序，必定包含一个package main，在这个main包中必定包含一个入口函数main，而这个函数既没有参数，也没有返回值。Go使用UTF-8字符串和标识符(因为UTF-8的发明者也就是Go的发明者之一)，所以它天生支持多语言。]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>Go语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】单点登录机制]]></title>
    <url>%2F2017%2F10%2F19%2Fzhuan%2Fsso_base%2F</url>
    <content type="text"><![CDATA[一、单系统登录机制1、http无状态协议 web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系 但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制 2、会话机制 浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联 服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式 1.请求参数2.cookie 将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息 tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图 3、登录状态 有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下 12HttpSession session = request.getSession();session.setAttribute("isLogin", true); 用户再次访问时，tomcat在会话对象中查看登录状态12HttpSession session = request.getSession();session.getAttribute("isLogin"); 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、多系统的复杂性 web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？ web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？ 单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie 既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如” ☀.baidu.com “，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。 然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。 因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录 三、单点登录 什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分 1、登录 相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明 1234567891011121314用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数sso认证中心发现用户未登录，将用户引导至登录页面用户输入用户名密码提交登录申请sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌sso认证中心带着令牌跳转会最初的请求地址（系统1）系统1拿到令牌，去sso认证中心校验令牌是否有效sso认证中心校验令牌，返回有效，注册系统1系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源用户访问系统2的受保护资源系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌系统2拿到令牌，去sso认证中心校验令牌是否有效sso认证中心校验令牌，返回有效，注册系统2系统2使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系 123局部会话存在，全局会话一定存在全局会话存在，局部会话不一定存在全局会话销毁，局部会话必须销毁 你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数 2、注销 单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明 3b139d2e-0b83-4a69-b4f2-316adb8997ce sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作 123456用户向系统1发起注销请求系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址sso认证中心向所有注册系统发起注销请求各注册系统接收sso认证中心的注销请求，销毁局部会话sso认证中心引导用户至登录页面 四、部署图 单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程 sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以 五、实现 只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server） sso-client 123456拦截子系统未登录用户请求，跳转至sso认证中心接收并存储sso认证中心发送的令牌与sso-server通信，校验令牌的有效性建立局部会话拦截用户注销请求，向sso认证中心发送注销请求接收sso认证中心发出的注销请求，销毁局部会话 sso-server 1234567验证用户的登录信息创建全局会话创建授权令牌与sso-client通信发送令牌校验sso-client令牌有效性系统注册接收sso-client注销请求，注销所有会话 接下来，我们按照原理来一步步实现sso吧！ 1、sso-client拦截未登录请求 java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截 123456789101112public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; HttpSession session = req.getSession(); if (session.getAttribute("isLogin")) &#123; chain.doFilter(request, response); return; &#125; //跳转至sso认证中心 res.sendRedirect("sso-server-url-with-system-url");&#125; 2、sso-server拦截未登录请求 拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样 3、sso-server验证用户登录信息 用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录” 123456@RequestMapping("/login")public String login(String username, String password, HttpServletRequest req) &#123; this.checkLoginInfo(username, password); req.getSession().setAttribute("isLogin", true); return "success";&#125; 4、sso-server创建授权令牌 授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子 1String token = UUID.randomUUID().toString(); 5、sso-client取得令牌并校验 sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行 1234567891011// 请求附带token参数String token = req.getParameter("token");if (token != null) &#123; // 去sso认证中心校验token boolean verifyResult = this.verify("sso-server-verify-url", token); if (!verifyResult) &#123; res.sendRedirect("sso-server-url"); return; &#125; chain.doFilter(request, response);&#125; verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档 12HttpPost httpPost = new HttpPost("sso-server-verify-url-with-token");HttpResponse httpResponse = httpClient.execute(httpPost); 6、sso-server接收并处理校验令牌请求 用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思） 令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。 令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话 7、sso-client校验令牌成功创建局部会话 令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行 123if (verifyResult) &#123; session.setAttribute("isLogin", true);&#125; sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求 8、注销过程 用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求 1234String logout = req.getParameter("logout");if (logout != null) &#123; this.ssoServer.logout(token);&#125; sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话 12345678@RequestMapping("/logout")public String logout(HttpServletRequest req) &#123; HttpSession session = req.getSession(); if (session != null) &#123; session.invalidate();//触发LogoutListener &#125; return "redirect:/";&#125; sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销 12345678public class LogoutListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent event) &#123;&#125; @Override public void sessionDestroyed(HttpSessionEvent event) &#123; //通过httpClient向所有注册系统发送注销请求 &#125;&#125;]]></content>
      <categories>
        <category>网络转载</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SSO</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC异常处理，全局异常和Controller通知]]></title>
    <url>%2F2017%2F09%2F16%2FSpring_in_Action%2FSpringException%2F</url>
    <content type="text"><![CDATA[1.Spring中的异常首先，要对异常有一个清晰的认识，刚学JAVA那会儿对异常的了解很是朦胧，只知道try catch 可以捕获异常，可以输出异常。打印出异常信息，对何时应该捕获，何时抛异常并不在乎。知道上班后才渐渐的对异常处理重视起来。一个程序不可能不出异常情况，关键在于我们能尽可能的预见将要发生的异常并提前对可能发生的异常进行处理，提高程序的健壮性。（PS:今天看了猩球崛起3，有点失望）Spring提供了多种方式将异常转换为响应： 特定的Spring异常将会自动映射为指定的HTTP状态码； 异常上可以添加@ResponseStatus注解，从而将其映射为某一个HTTP状态码； 在方法上可以添加@ExceptionHandler注解，使其用来处理异常 2.将异常映射为HTTP状态码 Spring异常 HTTP状态码 BindException 400 - Bad Request ConversionNotSupportedException 500 - Internal Server Error HttpMediaTypeNotAcceptableException 406 - Not Acceptable HttpMediaTypeNotSupportedException 415 - Unsupported Media Type HttpMessageNotReadableException 400 - Bad Request HttpMessageNotWritableException 500 - Internal Server Error HttpRequestMethodNotSupportedException 405 - Method Not Allowed MethodArgumentNotValidException 400 - Bad Request MissingServletRequestParameterException 400 - Bad Request MissingServletRequestPartException 400 - Bad Request NoSuchRequestHandlingMethodException 404 - Not Found TypeMismatchException 400 - Bad Reque 以上这些状态码是Spring默认使用的异常及对应状态码，我们也可自己映射到状态码用@ResponseStatus注解例如：1234567import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(value=HttpStatus.NOT_FOUND/*404*/, reason="找不到页面")public class SpittleNotFoundException extends RuntimeException &#123;&#125; 3.编写异常处理方法 将异常映射为状态码是一个简单易用的处理方案，但是在实际开放中我们除了要返回状态码还要返回错误信息和其他一些参数，上面这种方案显然不够用。所以我们得捕获异常并返回错误信息 最常见的方式是，在每个请求的方法里捕获异常并返回相应的错误信息，JSON数据或者跳转到错误页面 也可以在每个Controller里写一个公用的方法来统一处理异常，并用@ExceptionHandler标注，这样，当有@RequestMapping的方法发生异常时，@ExceptionHandler标注的方法就会捕捉到你指定的异常并执行方法，当然，也可以将这个异常方法写到一个BaseController里，其他Controller继承这个BaseController，甚至可以写一个全局的异常处理类，可以根据具体业务采取具体的方案 4.@ControllerAdvice为控制器添加通知控制器通知（controller advice）是任意带有@ControllerAdvice注解的类，这个类会包含一个或多个如下类型的方法： 来一个个看： @ExceptionHandler注解标注的方法；有@RequestMapping的方法发生异常时会执行; @InitBinder注解标注的方法； 前台传过来的参数都是String类型的，有些参数不能自动转换，比如Date，需要使用@initBinder注解为binder提供一个数据的转换器，这个转换器可以自己实现，也可以用spring官方的一些实现。 写个Double类型转换器12345678910111213141516import org.springframework.beans.propertyeditors.PropertiesEditor; public class DoubleEditor extends PropertiesEditor &#123; @Override public void setAsText(String text) throws IllegalArgumentException &#123; if (text == null || text.equals("")) &#123; text = "0"; &#125; setValue(Double.parseDouble(text)); &#125; @Override public String getAsText() &#123; return getValue().toString(); &#125; &#125; 然后用@InitBinder注册 12345@InitBinder protected void initBinder(WebDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"), true));//时间转换 binder.registerCustomEditor(double.class, new DoubleEditor()); //Double转换 &#125; @ModelAttribute注解标注的方法。被@ModelAttribute注释的方法会在此controller每个方法执行前被执行。1234567891011121314@Controller public class HelloModelController &#123; @ModelAttribute public void populateModel(@RequestParam String abc, Model model) &#123; model.addAttribute("attributeName", abc); &#125; @RequestMapping(value = "/helloWorld") public String helloWorld() &#123; return "helloWorld.jsp"; &#125; &#125; 访问控制器方法helloWorld时，会首先调用populateModel方法，将页面参数abc(/helloWorld.ht?abc=text)放到model的attributeName属性中，在视图中可以直接访问。1234567891011121314@Controller public class Hello2ModelController &#123; @ModelAttribute public User populateModel() &#123; User user=new User(); user.setAccount("ray"); return user; &#125; @RequestMapping(value = "/helloWorld2") public String helloWorld() &#123; return "helloWorld.jsp"; &#125; &#125; 前台可以通过user获取参数，如：${user.account} 在带有@ControllerAdvice注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。 1234567891011121314151617181920212223242526272829303132@ControllerAdvicepublic class AdviceHandler &#123; /** * 全局异常处理 */ @ExceptionHandler(&#123; UnauthenticatedException.class, AuthenticationException.class &#125;) @ResponseBody public ResponseData authenticationException(HttpServletRequest request, HttpServletResponse response) &#123; // 输出JSON ResponseData res = new ResponseData(); res.setCode(888).setMsg("未登录"); return res; &#125; /** *全局转换器 */ @InitBinder protected void initBinder(WebDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"), true));//时间转换 binder.registerCustomEditor(double.class, new DoubleEditor()); //Double转换 &#125; /** *全局返回数据 */ @ModelAttribute public User populateModel() &#123; User user=new User(); user.setAccount("ray"); return user; &#125;&#125; 5.URL重定向传参通过URL传参 如果username属性的值是habuma并且spitterId属性的值是42，那么结果得到的重定向URL路径将会是“/spitter/habuma?spitterId=42”。 使用flash属性略。。参考Spring in Action 第四版 7.5]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Spring in Action</category>
      </categories>
      <tags>
        <tag>Exception</tag>
        <tag>Spring</tag>
        <tag>Spring in Action</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc-文件上传]]></title>
    <url>%2F2017%2F09%2F13%2FSpring_in_Action%2FSpringMVC3%2F</url>
    <content type="text"><![CDATA[文件上传我一直感觉是个麻烦事，一提到文件上传我脑海中浮现的是二进制、byte数组、输入输出流、读写文件感觉头都大了，所以为了以后不再头大，正好最近在看Spring in Action 正好研究下，用各种姿势上传文件。传各种小黄片^-^。 1.Spring MVC中配置文件上传下面是我随手上传一张图片的请求体： 123456------WebKitFormBoundaryiYXA5UiOJRgWnKntContent-Disposition: form-data; name="upfile"; filename="0.jpg"Content-Type: image/jpeg------WebKitFormBoundaryiYXA5UiOJRgWnKnt-- DispatcherServlet并没有实现任何解析multipart请求数据的功能。它将该任务委托给了Spring中MultipartResolver策略接口的实现，通过这个实现类来解析multipart请求中的内容。从Spring 3.1开始，Spring内置了两个MultipartResolver的实现供我们选择： CommonsMultipartResolver：使用Jakarta CommonsFileUpload解析multipart请求； StandardServletMultipartResolver：依赖于Servlet 3.0对multipart请求的支持（始于Spring 3.1）。 一般优选StandardServletMultipartResolver,不过为什么我更喜欢StandardServletMultipartResolver呢？ 使用Servlet 3.0解析multipart请求（StandardServletMultipartResolver）在Spring应用上下文中，将其声明为bean就会非常简单，如下所示： 1234@Beanpublic MultipartResolver multipartResolver() throws IOException&#123; return new StandardServletMultipartResolver();&#125; 上面配置还不能正常使用，我们还需要设置存放路径，限制文件大小、类型等我们需在web.xml或Servlet初始化类中配置。如果我们采用Servlet初始化类的方式来配置DispatcherServlet的话，这个初始化类应该已经实现了WebApplicationInitializer，那我们可以在Servlet registration上调用setMultipartConfig()方法，传入一个MultipartConfigElement实例， 12345678910111213@Overrideprotected void customizeRegistration(Dynamic registration)&#123; registration.setMultipartConfig ( new MultipartConfigElement( "/tem/uploads",//路径 2097152, //上传文件的最大容量（以字节为单位）。默认是没有限制的。 4194304, //整个multipart请求的最大容量（以字节为单位），默认是没有限制的 0 //在上传的过程中，如果文件大小达到了一个指定最大容量（以字 //节为单位），将会写入到临时文件路径中。默认值为0，也就是 //所有上传的文件都会写入到磁盘上 ) );&#125; 配置类参考SpringMVC起步-构建Web应用程序 如果使用传统的xml配置，则在web.xml中配置如下： 使用Jakarta Commons FileUpload multipart解析器 Spring内置了CommonsMultipartResolver，可以作为StandardServletMultipartResolver的替代方案 将CommonsMultipartResolver声明为Spring bean的最简单方式如下： 2.处理multipart 请求（接收上传文件） 表单上设置enctype=multipart/form-data,也就是说Content-Type:multipart/form-data; 控制器接收参数上添加@RequestPart注解 这种用数组接收的方式很原始，没用文件类型，文件名等等，还要自己写流存文件。 接收MultipartFile将数组换成MultipartFile接收，内置方法如下： 将MultipartFile保存到七牛云，阿里云等云存储中 也就是利用MultipartFile获取文件信息保存到远程服务器，暂不写 Part接口：Spring MultipartFile的替代方案和上面的API差不多，值得一提的是，如果在编写控制器方法的时候，通过Part参数的形式接受文件上传，那么就没有必要配置MultipartResolver了。只有使用MultipartFile的时候，我们才需要MultipartResolver。 3.上传案列 下面是我在项目中随手写的一个上传文件类，本来项目使用的是百度的Ueditor上传文件，但是Ueditor是上传文件到项目的目录下面，每次部署war包都会覆盖原来的上传文件，必须先备份上传的文件，部署完项目后又重新传上去，很是麻烦。由于是前后端分离，前端静态资源部署在Nginx所以自己写了个上传请求将文件传到Nginx目录下边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112@Controller@Api(tags="文件上传")@RequestMapping("/file")public class FileUploadController &#123; /**文件存放主路径*/ @Value("$&#123;cnct.upload.file.path&#125;") private String baseFilePath; /**系统路径分隔符*/ public static final String FILE_SEPARATOR = System.getProperty("file.separator"); /**文件访问前缀，一般为Nginx路径*/ @Value("$&#123;cnct.request.file.path&#125;") private String requestFilePath; /** * 多文件上传 * @param request * @return */ @RequestMapping("/multipleFileUpload") @ResponseBody public List&lt;Map&lt;String, Object&gt;&gt; multipleFileUpload(HttpServletRequest request)&#123; List&lt;Map&lt;String,Object&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles("file"); if(files == null || files.size() == 0)&#123; return null; &#125; for(MultipartFile file : files)&#123;//遍历存文件 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); try &#123; // 截取上传文件的文件名 String uploadFilePath = file.getOriginalFilename(); String fileName = uploadFilePath .substring(uploadFilePath.lastIndexOf('\\') + 1, uploadFilePath.indexOf('.')); // 截取上传文件的后缀 String suffixName = uploadFilePath.substring( uploadFilePath.indexOf('.'), uploadFilePath.length()); String filePath = baseFilePath + new DateTime().getYear()+FILE_SEPARATOR +new DateTime().getMonthOfYear()+FILE_SEPARATOR +new DateTime().getDayOfMonth(); String realFileName = String.valueOf(new DateTime().getMillis()) + suffixName; File f = new File(filePath+FILE_SEPARATOR+realFileName); if(!f.getParentFile().exists())&#123; f.getParentFile().mkdirs(); &#125; f.createNewFile(); file.transferTo(f); map.put("original",fileName+suffixName); map.put("size",file.getSize()); map.put("state","SUCCESS"); map.put("title",realFileName); map.put("type",suffixName); map.put("url",requestFilePath+new DateTime().getYear()+ "/" +new DateTime().getMonthOfYear()+ "/" +new DateTime().getDayOfMonth()+ "/" +realFileName); &#125; catch (IOException e) &#123; System.err.println("文件不存在或者文件无权限"); map.put("state","ERROR"); e.printStackTrace(); &#125; res.add(map); &#125; return res; &#125; /** * 单文件上传 * @param file * @return */ @RequestMapping("/singleFileUpload") @ResponseBody public Map&lt;String , Object&gt; singleFileUpload(MultipartFile file)&#123; Map&lt;String,Object&gt; res = new HashMap&lt;&gt;(); try &#123; if (file.isEmpty()) &#123; res.put("state","ERROR"); return res; &#125; // 截取上传文件的文件名 String uploadFilePath = file.getOriginalFilename(); String fileName = uploadFilePath .substring(uploadFilePath.lastIndexOf('\\') + 1, uploadFilePath.indexOf('.')); // 截取上传文件的后缀 String suffixName = uploadFilePath.substring( uploadFilePath.indexOf('.'), uploadFilePath.length()); String filePath = baseFilePath + new DateTime().getYear()+FILE_SEPARATOR +new DateTime().getMonthOfYear()+FILE_SEPARATOR +new DateTime().getDayOfMonth(); String realFileName = String.valueOf(new DateTime().getMillis()) + suffixName; File f = new File(filePath+FILE_SEPARATOR+realFileName); if(!f.getParentFile().exists())&#123; f.getParentFile().mkdirs(); &#125; f.createNewFile(); file.transferTo(f); res.put("original",fileName+suffixName); res.put("size",file.getSize()); res.put("state","SUCCESS"); res.put("title",realFileName); res.put("type",suffixName); res.put("url",requestFilePath+new DateTime().getYear()+ "/" +new DateTime().getMonthOfYear()+ "/" +new DateTime().getDayOfMonth()+ "/" +realFileName); &#125; catch (IOException e) &#123; System.err.println("文件不存在或者文件无权限"); res.put("state","ERROR"); e.printStackTrace(); &#125; return res; &#125;&#125; 项目并发量不大，所以代码没过多优化设计。项目使用的是SpringBootspring: http: multipart: max-file-size: 100MB max-request-size: 100MB enabled: trueSpringBoot大发好，multipart都不需要配那么多那么麻烦，真是浪费生命]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Spring in Action</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring in Action</tag>
        <tag>SpringMVC</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc-渲染Web视图]]></title>
    <url>%2F2017%2F09%2F10%2FSpring_in_Action%2FSpringMvc-2%2F</url>
    <content type="text"><![CDATA[1.理解SpringMVC视图解析 上一篇讲到SpringMVC执行流程，DispatcherServlet会将模型和视图名交给视图解析器来解析生成响应视图 Spring MVC定义了一个名为ViewResolver的接口，它大致如下所示： 123public interface ViewResolver&#123; View resolveViewName(String viewName, Locale locale) throws Exception;&#125; 当给resolveViewName()方法传入一个视图名和Locale对象时，它会返回一个View实例。View是另外一个接口，如下所示： Locale对象，以便于恰当地格式化地域相关的值，如日期和货币。信息标签可以借助Spring的信息资源和Locale，从而选择适当的信息渲染到HTML之中。通例如：JSTL能够获得Locale对象以及Spring中配置的信息资源 1234public interface View&#123; String getContentType(); void render(Map&lt;String,?&gt; model, HttpServletRequest request,HttpServletResponse response) throws Exception;&#125; View接口的任务就是接受模型以及Servlet的request和response对象，并将输出结果渲染到response中。 我们只需实现这两个接口就可以解析视图了，不过Spring自带了13个视图解析器，能够将逻辑视图名转换为物理实现。 视图解析器 描述 BeanNameViewResolver 将视图解析为Spring应用上下文中的bean，其中bean的ID与视图的名字相同 ContentNegotiatingViewResolver 通过考虑客户端需要的内容类型来解析视图，委托给另外一个能够产生对应内容类型的视图解析器 FreeMarkerViewResolver 将视图解析为FreeMarker模板 InternalResourceViewResolver 将视图解析为Web应用的内部资源（一般为JSP） JasperReportsViewResolver 将视图解析为JasperReports定义 ResourceBundleViewResolver 将视图解析为资源bundle（一般为属性文件） TilesViewResolver 将视图解析为Apache Tile定义，其中tile ID与视图名称相同。注意有两个不同的TilesViewResolver实现，分别对应于Tiles 2.0和Tiles 3.0 UrlBasedViewResolver 直接根据视图的名称解析视图，视图的名称会匹配一个物理视图的定义 VelocityLayoutViewResolver 将视图解析为Velocity布局，从不同的Velocity模板中组合页面 VelocityViewResolver 将视图解析为Velocity模板 XmlViewResolver 将视图解析为特定XML文件中的bean定义。类似于BeanName-ViewResolver XsltViewResolver 将视图解析为XSLT转换后的结果 我们常用的也就那么几个，InternalResourceViewResolver一般会用于JSP，TilesViewResolver用于Apache Tiles视图（布局），而FreeMarkerViewResolver和VelocityViewResolver分别对应FreeMarker和Velocity模板视图 2.配置JSP视图解析器InternalResourceViewResolver会将视图名解析为JSP文件。另外，如果在你的JSP页面中使用了JSP标准标签库（JavaServer Pages Standard Tag Library，JSTL）的话，InternalResourceViewResolver能够将视图名解析为JstlView形式的JSP文件，从而将JSTL本地化和资源bundle变量暴露给JSTL的格式化（formatting）和信息（message）标签 1234567@Beanpublic ViewResolver viewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); return resolver;&#125; 当然如果喜欢xml配置方式也可以用xml配置，我个人喜欢JavaConf方式 支持JSTL 如果想让InternalResourceViewResolver将视图解析为JstlView，而不是InternalResourceView的话，那么我们只需设置它的viewClass属性即可：12345678@Beanpublic ViewResolver viewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setViewClass(org.springframework.web.servlet.view.JstlView.class) return resolver;&#125; 3.表单校验大多数项目都会有表单的提交，比如注册、登录等，我们通常会在前台通过JS对用户的输入进行校验，也可后台进行数据校验，前台校验的优点是不用发送请求，速度快，缺点是不安全，前端校验可以被轻易的绕开。后端的校验恰好相反。平时我们大多会在两端都进行校验，前端初步校验提高用户友好性，后端校验提高安全性。下面我们谈谈后端的校验。 最简单粗暴的方法是在后端获取参数后逐个写逻辑判断。这种方式会让我们的Controller很乱很臃肿。与其让校验逻辑弄乱我们的处理器方法，还不如使用Spring对Java校验API（Java Validation API，又称JSR-303）的支持。从Spring 3.0开始，在Spring MVC中提供了对Java校验API的支持。在Spring MVC中要使用Java校验API的话，并不需要什么额外的配置。只要保证在类路径下包含这个Java API的实现即可，比如Hibernate Validator。Java校验API定义了多个注解，这些注解可以放到属性上，从而限制这些属性的值。所有的注解都位于javax.validation.constraints包中 以下是JAVA校验API提供的一些注解： 注解 描述 @AssertFalse 所注解的元素必须是Boolean类型，并且值为false @AssertTrue 所注解的元素必须是Boolean类型，并且值为true @DecimalMax 所注解的元素必须是数字，并且它的值要小于或等于给定的BigDecimalString值 @DecimalMin 所注解的元素必须是数字，并且它的值要大于或等于给定的BigDecimalString值 @Digits 所注解的元素必须是数字，并且它的值必须有指定的位数 @Future 所注解的元素的值必须是一个将来的日期 @Max 所注解的元素必须是数字，并且它的值要小于或等于给定的值 @Min 所注解的元素必须是数字，并且它的值要大于或等于给定的值 @NotNull 所注解元素的值必须不能为null @Null 所注解元素的值必须为null @Past 所注解的元素的值必须是一个已过去的日期 @Pattern 所注解的元素的值必须匹配给定的正则表达式 @Size 所注解的元素的值必须是String、集合或数组，并且它的长度要符合给定的范围 例如： 实体类： 12345678910111213141516171819202122232425262728293031323334package spittr;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import org.apache.commons.lang3.builder.EqualsBuilder;import org.apache.commons.lang3.builder.HashCodeBuilder;import org.hibernate.validator.constraints.Email;public class Spitter &#123; private Long id; @NotNull @Size(min=5, max=16) private String username; @NotNull @Size(min=5, max=25) private String password; @NotNull @Size(min=2, max=30) private String firstName; @NotNull @Size(min=2, max=30) private String lastName; @NotNull @Email private String email; //get set 省略&#125; Controller 方法 1234567891011@RequestMapping(value="/register", method=POST) public String processRegistration( @Valid Spitter spitter, //校验输入 Errors errors) &#123; if (errors.hasErrors()) &#123; return "registerForm"; //校验出现错误则返回表单 &#125; spitterRepository.save(spitter); return "redirect:/spitter/" + spitter.getUsername(); &#125; 如果有校验出现错误的话，那么这些错误可以通过Errors对象进行访问，现在这个对象已作为processRegistration()方法的参数。（很重要一点需要注意，Errors参数要紧跟在带有@Valid注解的参数后面，@Valid注解所标注的就是要检验的参数。）processRegistration()方法所做的第一件事就是调用Errors.hasErrors()来检查是否有错误。 但这时候返回表单页面会丢失之前填的数据 4.使用Spring的JSP库 使用这个标签库可以将错误信息友好的显示在页面，也会保留验证钱的数据（解决上面的问题），当然也可以自己写处理，方式很多，不局限这一种 当为JSP添加功能时，标签库是一种很强大的方式，能够避免在脚本块中直接编写Java代码。Spring提供了两个JSP标签库，用来帮助定义Spring MVC Web的视图。其中一个标签库会用来渲染HTML表单标签，这些标签可以绑定model中的某个属性。另外一个标签库包含了一些工具类标签，我们随时都可以非常便利地使用它们。 具体使用方法请参考Spring in Action 6.2.2 5.使用Apache Tiles视图定义布局到现在为止，我们很少关心应用中Web页面的布局问题。每个JSP完全负责定义自身的布局，在这方面其实这些JSP也没有做太多工作。假设我们想为应用中的所有页面定义一个通用的头部和底部。最原始的方式就是查找每个JSP模板，并为其添加头部和底部的HTML。但是这种方法的扩展性并不好，也难以维护。为每个页面添加这些元素会有一些初始成本，而后续的每次变更都会耗费类似的成本。更好的方式是使用布局引擎，如Apache Tiles，定义适用于所有页面的通用页面布局。Spring MVC以视图解析器的形式为Apache Tiles提供了支持，这个视图解析器能够将逻辑视图名解析为Tile定义。 来感受下： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;&lt;!DOCTYPE tiles-definitions PUBLIC "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN" "http://tiles.apache.org/dtds/tiles-config_3_0.dtd"&gt;&lt;tiles-definitions&gt; &lt;definition name="base" template="/WEB-INF/layout/page.jsp"&gt; &lt;put-attribute name="header" value="/WEB-INF/layout/header.jsp" /&gt; &lt;put-attribute name="footer" value="/WEB-INF/layout/footer.jsp" /&gt; &lt;/definition&gt; &lt;definition name="home" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/home.jsp" /&gt; &lt;/definition&gt; &lt;definition name="registerForm" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/registerForm.jsp" /&gt; &lt;/definition&gt; &lt;definition name="profile" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/profile.jsp" /&gt; &lt;/definition&gt; &lt;definition name="spittles" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/spittles.jsp" /&gt; &lt;/definition&gt; &lt;definition name="spittle" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/spittle.jsp" /&gt; &lt;/definition&gt;&lt;/tiles-definitions&gt; 具体使用方法请参考Spring in Action 6.3]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Spring in Action</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring in Action</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】对于Java程序猿学习当中各个阶段的建议]]></title>
    <url>%2F2017%2F09%2F09%2Fzhuan%2Fzuoxiaolong%2F</url>
    <content type="text"><![CDATA[引言其实本来真的没打算写这篇文章，主要是LZ得记忆力不是很好，不像一些记忆力强的人，面试完以后，几乎能把自己和面试官的对话都给记下来。LZ自己当初面试完以后，除了记住一些聊过的知识点以外，具体的内容基本上忘得一干二净，所以写这篇文章其实是很有难度的。 但是，最近问LZ的人实在是太多了，为了避免重复回答，给自己省点力气，干脆就在这里统一回复了。 其实之前LZ写过一篇文章，但是那篇文章更多的是在讨论“面试前该不该刷题”这个话题，而这篇文章将会更加聚焦在面试前如何准备，以及工作当中如何学习这个话题上，而且会尽量写出一些干货。 第一个问题：阿里面试都问什么？ 这个是让LZ最头疼的一个问题，也是群里的猿友们问的最多的一个问题。 说实话，LZ只能隐约想起并发、JVM、分布式、TCP/IP协议这些个关键字，具体的问题真的是几乎都没记住。而且就算LZ记住了，也告诉你了，你也背会了，但LZ觉得，在面试中，你被问到一模一样问题的可能性依然很小。 甚至，就算你运气好被问到了，你也照着背下来了，也不一定就能对你的面试起到正面的作用，因为面试官万一多问一句，你可能就露馅了，那还不如干脆点说不会更好。 LZ参加的是阿里的社招面试，而社招不同于校招，问题的范围其实是很随机的。因为能参加一些比较知名的互联网公司社招的人，70%以上都会有个3-5年的经验。这倒不是说一两年经验的同学没有机会进这些公司，而是因为这种公司，大部分情况下只招一些比较资深的开发和应届生，而不招那些处于中间阶段的人。而1-2年经验的同学，往往就刚好处于这个尴尬的阶段。 对于能有3-5年经验的这部分人中，每个人的经历又都不同，所擅长的点也不一样，因此这就会导致每个人的问题和范围都不太一样。 很少说有哪个知名的互联网公司，比如BAT、京东、360、搜狐、网易等这些公司，其社招面试还有固定的问题和模式，让你可以像应届生面试一样，在面试前靠临时抱佛脚度过这一关。 大部分公司在社招的时候，不光是阿里，其它公司也都一样（因为LZ在一年多前也参加过很多其它知名互联网公司的面试，详情见《记录2015年年初跳槽的经历！》），基本上都分为两个阶段的提问。 第一个阶段是主语言本身以及它的高级特性，第二个阶段是讲述自己的项目，并在中间穿插着问题。 所以，LZ不妨就这两个阶段，谈谈社招面试的准备，而不是去把阿里面试的过程背一遍。说实话，LZ也确实记不住，所以不要再问LZ阿里面试都会问哪些问题了，你看看上面那个连接里的文章，也会发现，LZ里面也基本上没有写具体的问题，原因是一样的，真的记不住啊。（就是因为记忆力的问题，导致LZ从小偏科，文科成绩一直堪忧， 社招面试如何准备 LZ会分为四个部分来谈论这个问题，由于LZ本身是Java出身，因此关于主语言的问题，都是与Java相关，其它语言的同学可以选择性忽略。此外，面试的时候一般面试官的问题都是环环相扣，逐渐深入的，这点在下面大家可以更明显的感受出来。 1、主语言本身以及它的高级特性。 主语言当然就是你平日里拿来赚钱的家伙。不要告诉LZ你没有主语言，你会N多种语言，或者是你精通N多种语言，你要非这么说的话，你可以来杭州试试，LZ保证不打死你，最多打残。 LZ的主语言很显然是Java，那么对于Java来说，它的语言本身以及它的高级特性，都有哪些比较容易在面试中问到呢？ 一般情况下，主要有以下知识点很容易被问到。（PS：以下所列举的，都是一些Java相对而言比较高级一点的知识点，因为这里谈的是社招，而不是校招） 1）Java的数据结构相关的类实现原理，比如LinkedList，ArrayList，HashMap，TreeMap这一类的。以下简单模拟一个数据结构的连环炮。 比如，面试官先问你HashMap是不是有序的？ 你肯定回答说，不是有序的。那面试官就会继续问你，有没有有顺序的Map实现类？ 你如果这个时候说不知道的话，那这个问题就到此结束了。如果你说有TreeMap和LinkedHashMap。 那么面试官接下来就可能会问你，TreeMap和LinkedHashMap是如何保证它的顺序的？ 如果你回答不上来，那么到此为止。如果你依然回答上来了，那么面试官还会继续问你，你觉得它们两个哪个的有序实现比较好？ 如果你依然可以回答的话，那么面试官会继续问你，你觉得还有没有比它更好或者更高效的实现方式？ 如果你还能说出来的话，那么就你所说的实现方式肯定依然可以问你很多问题。 以上就是一个面试官一步一步提问的例子。所以，如果你了解的不多，千万不要敷衍，因为可能下一个问题你就暴露了，还不如直接说不会，把这个问题结束掉，赶紧切换到你熟悉的领域。 2）Java并发包当中的类，它们都有哪些作用，以及它们的实现原理，这些类就是java.concurrent包下面的。与上面一样，咱们也简单的模拟一个并发包的连环炮。 比如面试官可能会先问你，如果想实现所有的线程一起等待某个事件的发生，当某个事件发生时，所有线程一起开始往下执行的话，有什么好的办法吗？ 这个时候你可能会说可以用栅栏（Java的并发包中的CyclicBarrier），那么面试官就会继续问你，你知道它的实现原理吗？ 如果你继续回答的话，面试官可能会继续问你，你还知道其它的实现方式吗？ 如果你还能说出很多种实现方式的话，那么继续问你，你觉得这些方式里哪个方式更好？ 如果你说出来某一个方式比较好的话，面试官依然可以继续问你，那如果让你来写的话，你觉得还有比它更好的实现方式吗？ 如果你这个时候依然可以说出来你自己更好的实现方式，那么面试官肯定还会揪着这个继续问你。 为什么说面试的时候要引导面试官，原因就在这了。因为面试官的提问很多时候都是有迹可循的，你如果抓住了他的轨迹，能够猜到他下面很可能会问什么，那你在回答的时候就可以往你想要谈的方向去说。这样面试时就会显得更加从容，更加的游刃有余。 3）IO包和NIO包中的内容。这部分里面NIO会是重点，IO包大部分都会比较熟悉，因此可能会直接略过，直接问你NIO的内容。 IO包和NIO包的内容相对来说不是很多，首先NIO模型要熟悉，特别是其中的selector一定要非常清楚它的职责和实现原理。其实NIO的核心是IO线程池，一定要记住这个关键点。有的时候，面试官可能也会问你IO包的设计模式（装饰器模式），为什么要这样设计？ 有的面试官还会问你有没有更好的设计，这个时候如果你不知道请果断说自己现在的水平有限，想不出来更好的设计，千万不要信口开河，随意YY。 4）Java的虚拟机的内容。这部分主要包括三部分，GC、类加载机制，以及内存。 一个GC部分简单的连环炮。 面试官可以先问你什么时候一个对象会被GC？ 接着继续问你为什么要在这种时候对象才会被GC？ 接着继续问你GC策略都有哪些分类？ 你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？ 你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？ 你如果选出来了，继续问你，为什么要选择这个策略？ 下面是关于类加载机制的简单连环炮。 首先肯定是先问你Java的类加载器都有哪些？ 回答了这些以后，可能会问你每个类加载器都加载哪些类？ 说完以后，可能会问你这些类加载之间的父子关系是怎样的？ 你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？ 你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？ 你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？ 再来一个关于内存的连环炮。 首先肯定就是问你内存分为哪几部分，这些部分分别都存储哪些数据？ 然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？ 接着可能会问你，内存的哪些部分会参与GC的回收？ 完事以后，可能还会问你Java的内存模型是怎么设计的？ 你回答了以后，还会继续问你为什么要这么设计？ 问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？ 你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。 基本上Java语言本身以及语言稍微高级点的内容就是以上部分，如果你能把以上四部分了解的非常透彻，那基本上Java这部分就没啥问题了，因为光以上的内容就够你跟面试官聊很久了。你聊这些聊得久了，自然问你其它问题的时间就会短点。 你从LZ写这些问题的过程也应该能感受出来，很多时候，面试官都是顺着一条线一路问下去的，如果你觉得这条线你不熟悉的话，就要及时拐弯，引导面试官去问其它方面的问题。千万不要一直往下深入，直到自己跳不出来为止，那就尴了个尬了。 2、讲述自己的项目，并在中间穿插着问题 这一部分是面试过程中必问，也是聊得最久的一个阶段。除非你前面的语言部分非常扎实，扎实到面试官问了一两个小时，依旧没有探出你对语言本身的了解到底有多深。否则的话，你一定逃不过自己的项目这一关，而且一般情况下聊得时间不会太短。 这一部分内容，一般的模式就是你自己去讲你做过的项目，然后面试官会冷不丁的让你去解释其中某一部分，比如让你解释当时为什么要这么做，或者问你现在觉得有没有更好的办法。而这些穿插的问题，大部分与你的项目所用到的技术有关。而你需要做的，就是充分、再充分的去总结自己做过的项目（尤其是最近的一两个项目），挖掘出一个甚至N个亮点，以备于到时候可以让面试官产生眼前一亮的感觉。如果你能达到这种效果的话，基本上离你成功就不远了。 这部分内容由于和每个人自己的经历息息相关，因此这里也没法列举可能问到的问题。这篇文章《程序员面经：面试前到底该不该刷题以及面试前该如何准备》是LZ之前写的，里面大概讨论了下如何在面试前总结，有兴趣的可以去了解一下。 3、额外的加分项 上面两个阶段基本上是必问的，还有一些加分项。这些加分项中，有些内容面试官也会问你（比如TCP/IP协议、算法），但更多的是会先问你了解不了解，你了解的话再继续聊，不了解的话就直接略过了，不至于因为这种问题而直接把你打入地狱。 下面LZ列举一下这些加分项，如果可以的话，这些加分项还是要争取一下的。 计算机系统原理。网络通信协议（TCP/IP，HTTP等）。数据结构与算法。著名开源项目的源码。你自己有很棒的开源项目。你的个人博客。待评论区补充。这几项当中，对于前1-3项，如果你之前就比较了解，只是由于时间问题忘记了的话，还是可以临时抱佛脚一下的。至于后面4-6项，就需要你日常的积累了，不是一时半会儿能做到的。如果你平日里没有积累，那么后面这三个加分项只能抛弃了。 4、与你职位相关的内容 其实这最后一项是对前面三项的补充，你应该尽量去主攻和你面试的职位相关的内容。比如你面试一个实时计算的职位，那么你的算法最好要厉害，对于著名的实时计算开源项目要熟悉，最好阅读过源码，而且还要对分布式系统有一定的见解。 因此，这个第4部分没有具体的内容，只是提醒你，如果你很明确自己的面试职位，最好在面试前准备的时候，尽量朝职位的需求方向靠拢，这样成功的可能性更大。 对于Java程序猿学习的建议 这一部分其实也算是今天的重点，这一部分用来回答很多群里的朋友所问过的问题，那就是LZ你是如何学习Java的，能不能给点建议？ 今天LZ是打算来点干货，因此咱们就不说一些学习方法和技巧了，直接来谈每个阶段要学习的内容甚至是一些书籍。这一部分的内容，同样适用于一些希望转行到Java的同学。 在大家看之前，LZ要先声明两点。 1、由于LZ本人是Java后端开发出身，因此所推荐的学习内容是Java Web和Java后端开发的路线，非Java Web和Java后端开发的同学请适当参考其学习思想即可，切勿照搬。 2、下面对于【第一部分】的推荐内容，目的是让你尽快成为一个可以参加工作的Java开发者，更适用于处于待业状态，准备转行Java的同学。如果你是在校学生，务必要在学好基础（比如计算机系统、算法、编译原理等等）的前提下，再考虑去进行下面的学习。 第一部分：对于尚未做过Java工作的同学，包括一些在校生以及刚准备转行Java的同学。 一、Java基础首先去找一个Java的基础教程学一下，这里可以推荐一个地址，或者你也可以参照这个地址上去找相应的视频。 学习Java基础的时候，应该尽量多动手，很多时候，你想当然的事情，等你写出来运行一下，你就会发现不是这么回事儿，不信你就试试。 学完以上内容以后，你应该对Java有一个基本的了解了，你可以用Java语言写出一些简单的程序，并且你用的是最简单的编辑器，比如记事本。 这个时候，不要急于进入下一部分，留下几天好好写一些程序，尽可能熟悉这些基础内容。 二、Web开发等你写上几天程序以后，你往往会比较迷茫，因为你写的东西似乎看起来毫无用处，比如实现一个简单的计算器，读取一个文件等。这个时候你就应该去学着写一些让你觉得有意思的东西了，所以你应该学习更多的知识。 这些内容主要是Web开发相关的内容，包括HTML/CSS/JS（前端页面）、Servlet/JSP（J2EE）以及Mysql（数据库）相关的知识。 它们的学习顺序应该是从前到后，因此最先学习的应该是HTML/CSS/JS（前端页面），这部分内容你可以去上面的那个runoob网站上找。你可以试着自己写一些页面，当然，你可以尽你最大的努力让它变得最漂亮。这部分内容对于后端Java来说，理论上不是特别重要，但至少要达到可以自己写出一些简单页面的水平。 接下来，你需要学习的是Servlet/JSP（J2EE）部分，这部分是Java后端开发必须非常精通的部分，因此这部分是这三部分中最需要花精力的，而且这个时候，你要学会使用开发工具，而不能再使用记事本了，可以选择eclipse。 当你下载安装好eclipse以后，请视频中的教程一步一步去学习，一定要多动手。关于Servlet/Jsp部分视频的选择，业界比较认可马士兵的视频，因此推荐给大家。当然了，LZ本人并没有看过他的视频，所以不好说的太绝对，如果大家自己有更好的选择，可以坚持自己的，不要被LZ干扰。 原本LZ也是打算出教学视频的，但是由于时间问题，还是决定放弃了。但是如果你看视频的过程中遇到了问题，欢迎来LZ的交流群提问，或者去斗鱼观看LZ的直播提出你的问题，直播地址和群号都在LZ的个人博客左侧。 最后一步，你需要学会使用数据库，mysql是个不错的入门选择，而且Java领域里主流的关系型数据库就是mysql。这部分一般在你学习Servlet/Jsp的时候，就会接触到的，其中的JDBC部分就是数据库相关的部分。你不仅要学会使用JDBC操作数据库，还要学会使用数据库客户端工具，比如navicat，sqlyog，二选一即可。 三、开发框架当你学会以上内容以后，这个时候你还不足以参加工作，你还需要继续深造。公司里为了提高开发的效率，会使用一些Java Web框架，因此你还需要学习一些开发框架。 目前比较主流的是SSM框架，即spring、springmvc、mybatis。你需要学会这三个框架的搭建，并用它们做出一个简单的增删改查的Web项目。你可以不理解那些配置都是什么含义，以及为什么要这么做，这些留着后面你去了解。但你一定要可以快速的利用它们三个搭建出一个Web框架，你可以记录下你第一次搭建的过程，相信我，你一定会用到的。 还要提一句的是，你在搭建SSM的过程中，可能会经常接触到一个叫maven的工具。这个工具也是你以后工作当中几乎是必须要使用的工具，所以你在搭建SSM的过程中，也可以顺便了解一下maven的知识。在你目前这个阶段，你只需要在网络上了解一下maven基本的使用方法即可，一些高端的用法随着你工作经验的增加，会逐渐接触到的。 关于学习SSM框架的地址给大家推荐一个，这里面有视频，大家可以去观看。 四、找工作当你完成开发框架的学习以后，你就该找工作了，在校的找实习，毕业的找全职。与此同时，在找工作的同时，你不应该停下你的学习，准确的说，是你在以后都不能停下学习。 上面这些内容你只是囫囵吞枣的学会了使用，你可以逐步尝试着去了解更多的东西，网络是你最重要的老师。 第一部分：对于参加工作一年以内的同学。恭喜你，这个时候，你已经拥有了一份Java的工作。这个阶段是你成长极快的阶段，而且你可能会经常加班。 但是加班不代表你就可以松懈了，永远记得LZ说的那句话，从你入行那一刻起，你就要不停的学习。在这一年里，你至少需要看完《Java编程思想》这本书。这本书的内容是帮助你对于Java有一个更加深入的了解，是Java基础的升级版。 这本书很厚，当初看这本书，LZ花了整整三个月。正常速度的话，应该可以在半年左右看完。LZ这里不要求过高，只要你在一年以内把这本书看完即可。当然了，LZ所说的看完，是充分吸收，而不是读一遍就完事了，因此有些内容你可能会看不止一遍。 总而言之，这个阶段的核心学习思想就是，在工作中实践，并且更加深入的了解Java基础。 第二部分：对于参加工作1年到2年的同学。这部分时间段的同学，已经对Java有了一个更加深入的了解。但是对于面向对象的体会可能还不够深刻，编程的时候还停留在完成功能的层次，很少会去考虑设计的问题。 于是这个时候，设计模式就来了。LZ当时看的是《大话设计模式》这本书，并且写了完整版的设计模式博客。因此，LZ要求大家，最多在你工作一年的时候，必须开始写博客，而设计模式就是你博客的开端。 请记住，LZ所提的基本都是最低要求，因此不要有任何松懈的心理，否则五年后，你不要去羡慕别人高于你的工资，也不要去羡慕别人进入了某公司。 这一年，你必须对于设计模式了如指掌，《大话设计模式》可以作为你的开端。当然了，你也可以去看LZ的个人博客去学习，地址请点击这里。 此外，设计模式并不是你这一年唯一的任务，你还需要看一些关于代码编写优化的书。比如《重构 改善既有代码的设计》，《effective java》。 总而言之，这个阶段，你的核心任务就是提高你的代码能力，要能写出一手优雅的代码。 第三部分：对于参加工作2年到3年的同学有的同学在这个时候觉得自己已经很牛逼了，于是忍不住开始慢慢松懈。请记住，你还嫩的多。 这个阶段，有一本书是你必须看的，它叫做《深入理解Java虚拟机》。这本书绝对是Java开发者最重要的书，没有之一。在LZ眼里，这本书的重要性还要高于《Java编程思想》。 这本书的内容是帮助你全面的了解Java虚拟机，在这个阶段，你一定已经知道Java是运行在JVM之上的。所以，对于JVM，你没有任何理由不了解它。LZ之前有写过JVM系列的知识，可以去看一下，地址请点击这里。 另外，在过去2年的工作当中，你肯定或多或少接触过并发。这个时候，你应该去更加深入的了解并发相关的知识，而这部分内容，LZ比较推荐《Java并发编程实战》这本书。只要你把这本书啃下来了，并发的部分基本已经了解了十之六七。 与此同时，这个阶段你要做的事情还远不止如此。这个时候，你应该对于你所使用的框架应该有了更深入的了解，对于Java的类库也有了更深入的了解。因此，你需要去看一些JDK中的类的源码，也包括你所使用的框架的源码。 这些源码能看懂的前提是，你必须对设计模式非常了解。否则的话，你看源码的过程中，永远会有这样那样的疑问，这段代码为什么要这么写？为什么要定义这个接口，它看起来好像很多余？ 由此也可以看出，这些学习的过程是环环相扣的，如果你任何一个阶段拉下来了，那么你就真的跟不上了，或者说是一步慢步步慢。而且LZ很负责的告诉你，LZ在这个阶段的时候，所学习的东西远多于这里所罗列出来的。因此千万不要觉得你已经学的很多了，LZ所说的这些都只是最低要求，不光是LZ，很多人在这个时间段所学习的内容都远超本文的范围。 如果你不能跟上节奏的话，若干年后，如果不是程序猿市场还不错的话，你很可能不仅仅是工资比别人低，公司没别人好，而是根本就找不到工作。 总而言之，这个阶段，你需要做的是深入了解Java底层和Java类库（比如并发那本书就是Java并发包java.concurrent的内容），也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。 另外，还有一种学习的方式，在2年这个阶段，也应该启用了，那就是造轮子。 不要听信那套“不要重复造轮子”的论调，那是公司为了节省时间成本编造出来的。重复造轮子或许对别人没有价值，因为你造的轮子可能早就有了，而且一般情况下你造出来的轮子还没有现存的好。但是对别人没有价值，不代表对你自己没有价值。 一个造轮子的过程，是一个从无到有的过程。这个过程可以对你进行系统的锻炼，它不仅考察你的编码能力，还考察你的框架设计能力，你需要让你的轮子拥有足够好的扩展性、健壮性。 而且在造轮子的过程中，你会遇到各种各样的难题，这些难题往往又是你学习的契机。当你把轮子造好的时候，你一定会发现，其实你自己收获了很多。 所以，这个阶段，除了上面提到的了解JVM、JDK和框架源码以外，也请你根据别人优秀的源码，去造一个任何你能够想象出来的轮子。 第四部分：参加工作3年到4年的同学这个阶段的同学，提升已经是很难了，而且这个阶段的学习往往会比较多样化。 因为在前3年的过程中，你肯定或多或少接触过一些其它的技术，比如大数据、分布式缓存、分布式消息服务、分布式计算、软负载均衡等等。这些技术，你能精通任何一项，都将是你未来面试时巨大的优势，因此如果你对某一项技术感兴趣的话，这个时候可以深入去研究一下。这项技术不一定是你工作所用到的，但一定是相关的。 而且在研究一门新技术时，切忌朝三暮四。有的同学今天去整整大数据，搞搞Hadoop、hbase一类的东西。过不了一段时间，就觉得没意思，又去研究分布式缓存，比如redis。然后又过不了一段时间，又去研究分布式计算，比如整整Mapreduce或者storm。 结果到最后，搞得自己好像什么都会一样，在简历上大言不惭的写上大数据、分布式缓存、分布式计算都了解，其实任何一个都只是浮于表面。到时候面试官随便一问，就把你给识破了。 一定要记住，作为一个程序猿，平日里所接触的技术可能会很多，但是想要让一门技术成为你的优势，那么一定是你对这门技术的了解强过绝大多数人才行。 因此在这个阶段，你就不能再简单的去学习前3年的内容了，虽然前面的学习如果还不够深入的话依旧要继续，但这个时候你应该更多的考虑建立你的优势，也可以称为差异性。 差异性相信不难理解，就是让你自己变得与众不同。你前面三年的学习足够你成为一名基本合格的Java开发者，但你离成为一名优秀的Java开发者还有很大的距离。 所谓优秀，即能别人所不能。而你前三年所学习的内容，是很多做过几年的Java开发都能够掌握的。那么为了让自己有差异性，你就需要另辟蹊径，找一个方向深入研究下去，以期在将来，你能够成为这个领域的专家，比如分布式计算领域的专家，大数据领域的专家，并发领域的专家等等。 此外，你除了建立你的差异性之外，还要去弥补你基础上的不足，直到现在，LZ都没有提及基础知识。原因是基础是很枯燥无味的，学的太早不仅容易懵逼，而且懵逼的同时还容易产生心理阴影，以至于以后再不想去研究这些基础。但基础又是你深入研究一些领域时所必须掌握的，比如你去研究分布式计算，你不懂算法你玩个毛毛？比如你去做分布式缓存，你对计算机系统的内存不了解，你如何去做缓存？ 如果你的基础本来就非常强，那么恭喜你，相信你在之前的工作中已经充分体会到了这些基础对你的帮助。但LZ相信大部分人的基础都很薄弱，哪怕是科班毕业的人，很多人也不敢说自己当初的基础学的多么强大，比如算法、计算机系统原理、编译原理这些。 但是每个人时间都是有限的，而且这些基础的书籍每一本读下来，没个一年半载的，还真拿不下来，因此还是要有所抉择的。虽然艺多不压身，但问题是艺多是有代价的，是需要你付出时间和精力的，而LZ个人更赞成在同等代价的情况下获取最大的收获。 首先，LZ比较推崇的基础书籍有三本，分别是《深入理解计算机系统》，《tcp/ip详解 卷一、二、三》，《数据结构与算法》。其中TCP/IP有三本书，但我们这里把这三本看成是一本大书。 这三本分别适合三种人，《深入理解计算机系统》比较适合一直从事Java Web开发和APP后端开发工作的人群。《tcp/ip详解 卷一、二、三》比较适合做网络编程的人群，比如你使用netty去开发的话，那么就要对TCP/IP有更深入的了解。而《数据结构与算法》这本书，则比较适合做计算研究工作的人，比如刚才提到的分布式计算。 另外，LZ要强调的是，这里所说的适合，并不是其它两本对你就没有用。比如你做Java Web和APP后端开发，《tcp/ip详解 卷一、二、三》这本书对你的作用也是很大的。这里只是分出个主次关系而已，你要是时间足够的话，能把三本都精读那当然最好不过了。但如果时间有限的话，那么就先挑对你帮助最大的书去读。 理论上来讲，这一年你能把这三本其中一本精读下来，就已经非常厉害了。有了基础，有了前面的工作经验，你就可以去开拓属于你的领域了。 在这一年里，一定要规划好自己的领域，建立好自己的优势，制造出差异性。如果你对自己的领域不够清晰的话，随着你工作的时间日益增多，你接触的技术会越来越多，这个时候，你很容易被淹死在技术的海洋里，看似接触的技术越来越多，会用的也越来越多，但你毫无优势。 有的同学可能会问，“LZ，我也不知道我的领域是什么啊？怎么办呢？” 对于这种人，LZ只想说，“卧槽，这还问我？要不干脆我替你学习得了，好不好？” 第五部分：参加工作4年到5年的同学经过前面一年的历练，相信你在自己所钻研的领域已经有了自己一定的见解，这个时候，技术上你应该已经遇到瓶颈了。 这个时候不要着急提高自己的技术，已经是时候提高你的影响力了，你可以尝试去一些知名的公司去提高你的背景，你可以发表一些文章去影响更多的人。当然，你也可以去Github创建一个属于你的开源项目，去打造自己的产品。这次的开源项目不同于之前的造轮子，你这个时候是真的要去尽量尝试造出来真正对别人有价值的轮子。 技术学到这个阶段，很容易遇到瓶颈，而且往往达到一定程度后，你再深入下去的收效就真的微乎其微了，除非你是专门搞学术研究的。然而很可惜，大部分程序猿做不到这一步，那是科学家做的事情。 这个时候提高影响力不仅仅是因为技术上容易遇到瓶颈，更多的是影响力可以给你创造更多的机会。程序猿在某种程度上和明星很像，一个好的电视剧和电影就可以成就一批明星，程序猿有的时候也是，一个好的项目就可以成就一群程序猿。 比如国内几个脍炙人口的项目，像淘宝、支付宝、QQ、百度、微信等等。这每一个项目，都成就了一批程序猿。LZ敢说，这里面任何一个项目，如果你是它的核心开发，光是这样一个Title，就已经是你非常大的优势。更何况还不止如此，Title说到底也是个名头，更重要的是，这种项目在做的时候，对你的历练一定也是非常给力的。 而你如果想要参与这样的项目，除了靠运气之外，影响力也是很重要的一个手段。比如你在分布式计算领域有一定的影响力，那么如果有什么好的关于分布式计算的项目，对方就很可能会邀请你。就算人家不邀请你，你自己主动去面试的时候，对方如果知道你在这个领域的影响力，也肯定会起到很大的作用，而这个作用，甚至可能会超过你现在的技术能力。 所以，在这个阶段，你最大的任务是提高自己的影响力，为自己未来的十年工作生涯那一天做准备。如果你能够靠你的影响力和以前积累的技术，参与到一个伟大的项目当中，那么你后面的五年也就有着落了。 当然了，LZ现在满打满算，做程序猿也就4年半不到，因此关于4年到5年这一部分，LZ的见解不一定是对的，就算是对的，也不一定是适合任何人的。所以，希望大家自己有的判断力，去决定到底该如何度过这一年。 结语 本文到此就基本结束了，整篇文章很长，但其实主要就说了两部分内容，一个是社招面试的准备，一个是Java生涯的学习。 关于这两部分，LZ已经给出了自己的见解，但是还是那句话，每个人吸收知识的时候，都要有抽取精华，去除糟粕的能力。LZ所说的，可能有些是对的，有些是错的，有些是适合你的，有些是不太适合你的，你要自己能够判断。 其实你在生活和工作当中也是一样的，你身边的人形形色色，有的人你喜欢，有的人你很讨厌。但其实你喜欢的人也有缺点，你讨厌的人也有优点。你要学会从你讨厌的人身上学会他的优点，千万不要一棒子打死，这只会让你失去很多学习成长的机会。 好了，说了这么多了，就到此为止吧，希望本文可以帮助到作为程序猿或即将成为程序猿的你。 转自左潇龍博客http://www.zuoxiaolong.com/blog/article.ftl?id=184]]></content>
      <categories>
        <category>网络转载</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>学习</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC起步-构建Web应用程序]]></title>
    <url>%2F2017%2F09%2F04%2FSpring_in_Action%2FSpringMVC-1%2F</url>
    <content type="text"><![CDATA[1.SpringMVC流程图先来看看流程图，从浏览器发送请求到响应完成经过的流程 2.配置DispatcherServlet DispatcherServlet是Spring MVC的核心所有请求都将经过它。 12345678910111213141516171819public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;@Overrideprotected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;;//这里用RootConfig类来配置根上下文（里面是一些Bean）&#125;@Overrideprotected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;;//这里用WebConfig类来配置Servlet上下文（里面是一些Bean）&#125;@Overrideprotected String[] getServletMappings() &#123; return new String[] &#123; "/" &#125;;&#125;&#125; AbstractAnnotationConfigDispatcherServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。GetServletConfigClasses()方法返回的带有@Configuration注解的类将会用来定义DispatcherServlet应用上下文中的bean。getRootConfigClasses()方法返回的带有@Configuration注解的类将会用来配置ContextLoaderListener创建的应用上下文中的bean。 3.AbstractAnnotationConfigDispatcherServletInitializer剖析在Servlet 3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果能发现的话，就会用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring 3.2引入了一个便利的WebApplicationInitializer基础实现，也就是AbstractAnnotationConfigDispatcherServletInitializer。因为我们的Spittr-WebAppInitializer扩展了AbstractAnnotationConfig DispatcherServlet-Initializer（同时也就实现了WebApplicationInitializer），因此当部署到Servlet 3.0容器中的时候，容器会自动发现它，并用它来配置Servlet上下文. 4.启用Spring MVC 最少配置但勉强能用的Spring MVC配置 12345678910111213141516171819202122232425@Configuration //配置类注解@EnableWebMvc //启用Spring MVC@ComponentScan("spittr.web") //启用组件扫描public class WebConfig extends WebMvcConfigurerAdapter &#123;@Beanpublic ViewResolver viewResolver() &#123;//配置JSP视图解析器 InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); return resolver;&#125;//配置静态资源的处理@Overridepublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable();&#125;@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; // TODO Auto-generated method stub super.addResourceHandlers(registry);&#125;&#125; 5.AbstractAnnotationConfigDispatcherServletInitializer额外配置上面我们继承了AbstractAnnotationConfigDispatcherServletInitializer并重写了三个方法来配置上下文，但实际上还有更多的方法可以进行重载，从而实现额外的配置。 此类的方法之一就是customizeRegistration()。在AbstractAnnotationConfigDispatcherServletInitializer将DispatcherServlet注册到Servlet容器中之后，就会调用customizeRegistration()，并将Servlet注册后得到的Registration.Dynamic传递进来。通过重载customizeRegistration()方法，我们可以对DispatcherServlet进行额外的配置 使用customizeRegistration()配置文件上传 123456@Overrideprotected void customizeRegistration(Dynamic registration)&#123; registration.setMultipartConfig ( new MultipartConfigElement("/tem/uploads") );&#125; 6.添加其他的Servlet和Filter按照AbstractAnnotationConfigDispatcherServletInitializer的定义，它会创建DispatcherServlet和ContextLoaderListener。但是，如果你想注册其他的Servlet、Filter或Listener的话，那该怎么办呢？基于Java的初始化器（initializer）的一个好处就在于我们可以定义任意数量的初始化器类。因此，如果我们想往Web容器中注册其他组件的话，只需创建一个新的初始化器就可以了。最简单的方式就是实现Spring的WebApplicationInitializer接口。]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Spring in Action</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring in Action</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring in Anction:Spring AOP 小记]]></title>
    <url>%2F2017%2F08%2F22%2FSpring_in_Action%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[1.什么是AOP（面向切面编程） 不扯那些概念的东西，简单说来AOP是OOP的一个补充，AOP可以在程序运行期追加一些公用的功能，比如权限判断，日志记录，这些功能都是项目需要的，但是又不能每个地方都调用，这样无疑增加了代码的复杂度和工作量，我们可以将这些分散在系统中的公用代码集中于一个地方并通过aop技术应用于系统各个地方。 2. AOP术语 切点：我们需要插入这些公用功能的点？比如哪些类？哪些方法？等等（何处调用） 切面：这些公用功能代码（调用什么） 通知：在什么时候调用？ 3.通知分类 前置通知（Before）：在目标方法调用前调用 后置通知（After）：在目标方法调用后调用 返回通知（AfterReturning）：在目标方法成功执行后调用 异常通知（AfterThrowing）：在目标方法执行失败抛异常后调用 环绕通知（Around）：将目标方法包裹，由你决定什么时候调用（最强大，最常用）3.Spring AOPSpring 通过生成代理类将目标对象包裹从而实现AOP，调用者调用目标方法时，其实是在调用代理类，再由代理类调用目标方法，从而控制对目标方法的调用，Spring只支持最细方法级别的连接点，如果需要实现更细粒度的控制则需要借助专业的AOP框架AspectJ，可以控制字段，构造方法等更细的东西，不过需要学习新的语法。 4.Spring 切点表达式可以通过这些表达式配置切点 上面是Spring支持的AspectJ 切点表达式。除execution是增加切点范围的外，其他都是用于缩小范围 5.编写切点 6.编写切面用注解@Aspect表示一个切面，注解用于类上 1234567891011121314151617181920@Aspect //表示是切面@Component //Bean注入Spring@Order(1)//优先执行该切面public class TicketLoginAspect &#123; @Autowired private HttpServletRequest request; /** * 切点 */ //表示作用于TicketLogin注解 @Pointcut("@annotation(com.cnct.webchat.common.annotation.TicketLogin)") public void loginPointCut() &#123; //扩展作用范围，不用在每个@Around后写很长的表达式了，只需写方法名即可，像下面 &#125; @Around("loginPointCut()") public Object around(ProceedingJoinPoint point) throws Throwable &#123; &#125; &#125; 写完切面后要开启Spring aop自动代理才能生效，如果使用JavaConfig的话，在配置类上使用@EnableAspectJ-AutoProxy即可，如果用XML配置则加入aop:aspectJ-autoproxy/ 7.通过注解为目标类增加新功能（方法）既然AOP通过代理实现，那么就可以为目标对象增加新的代理方法。 12345678@Aspect //定义切面@Componentpublic class TestAop&#123; @DeclareParents(value = "com.lyq3.NewFunctionInterface+", defaultImpl = NewFunctionImpl.class ) public static Abc abc;&#125; value 指定那种类型的Bean要引入，（后面的“+”号表示所有的子类型而不是本身） defaultImpl 指定引入功能的实现类 @DeclareParents 所标注的静态属性指明要引入的接口，也就是要为Abc接口增加新功能 8.注意：踩坑记12345678910111213141516171819202122232425262728293031323334@Aspect@Component@Order(2)//登录注解执行后执行该注解public class HandleRecordAspect &#123; @Autowired private HandleRecordMapper handleRecordMapper; @Autowired private HttpSession session; /** * 切点 */ @Pointcut("@annotation(com.cnct.webchat.common.annotation.HandleRecord)") public void handlePointCut() &#123; &#125; @Around("handlePointCut()") public Object around(ProceedingJoinPoint point) throws Throwable &#123; //先执行方法 Object result = point.proceed(); //访问目标方法的参数： Object[] args = point.getArgs(); Signature sig = point.getSignature(); MethodSignature msig = null; msig = (MethodSignature) sig; Method method = msig.getMethod();// String methodName = msig.getName();//方法名 HandleRecord handleRecord = method.getAnnotation(HandleRecord.class);//获取注解 //操作标识（增?删?改?） int handle_status = handleRecord.handle_status(); String remark = handleRecord.value(); &#125; &#125; 上面的代码是我在项目中实现一个存操作纪录的部分代码，咋一看没毛病。@HandleRecord这个自定义注解在Controller层能用，我放到Service层的时候（service有接口和接口实现，注解放实现类方法上）1HandleRecord handleRecord = method.getAnnotation(HandleRecord.class); 这句代码是获取不到注解的，也就是说 handleRecord = null; 原因是AOP采用的jdk代理，MethodSignature 转型之后,会丢失子类的方法注解，所以得先获取实现类的方法 修改下代码，就能用了： 1234567891011121314151617//先执行方法 Object result = point.proceed(); //访问目标方法的参数： Object[] args = point.getArgs(); Signature sig = point.getSignature(); MethodSignature msig = null; msig = (MethodSignature) sig; Method method = msig.getMethod(); //MethodSignature 转型之后,会丢失子类的方法注解，所以得先获取实现类的方法 //============================================ Method soruceMethod = point.getTarget().getClass().getMethod(method.getName(), method.getParameterTypes()); //============================================= HandleRecord handleRecord = soruceMethod.getAnnotation(HandleRecord.class);//获取注解 //操作标识（增?删?改?） int handle_status = handleRecord.handle_status(); String remark = handleRecord.value(); 详情查看Spring in Action 第四版 第四章]]></content>
      <categories>
        <category>看书笔记</category>
        <category>Spring in Action</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring in Action</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[org.thymeleaf.exceptions.TemplateInputException:template might not exist or might not be accessible by any of the configured Template Resolvers]]></title>
    <url>%2F2017%2F08%2F20%2FTemplateInputException%2F</url>
    <content type="text"><![CDATA[1.Thymeleaf最近大量使用SpringBoot替代Spring，然而SpringBoot推荐用thymeleaf取代JSP，既然官方都推荐了那就用呗妹的，刚开始用到处都是坑，得踩一段时间才能踩完。 2.格式检测Thymeleaf的格式检测有点严格，连html标签没闭合也报错，使用VUE等前端框架时会用很多自定义的标签，会无限报错的，很是不习惯。可以通过引入额外的库解决 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; 配置application.yml: 123thymeleaf: cache: false mode: LEGACYHTML5 OK! 不会报错了 3.Thymeleaf模板布局–报错TemplateInputException来说说Thymeleaf的网页布局,jsp布局我们用include引入代码片段组装网页，Thymeleaf也有类似的功能 但是，TMD报错了： 12345678org.thymeleaf.exceptions.TemplateInputException: Error resolving template "html/index", template might not exist or might not be accessible by any of the configured Template Resolvers at org.thymeleaf.TemplateRepository.getTemplate(TemplateRepository.java:246) ~[thymeleaf-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1104) ~[thymeleaf-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1060) ~[thymeleaf-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1011) ~[thymeleaf-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:335) ~[thymeleaf-spring4-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:190) ~[thymeleaf-spring4-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) ~[spring-webmvc-4.3.9.RELEASE.jar:4.3.9.RELEASE] 这很明显是路径问题，报错原因是Thymeleaf默认模板存放在resources/templates下面，而我在里面多放了一个html文件夹然后 1return "html/index"; 这样本来没错是可以访问页面的，但是在首页引入其他模板的时候 1&lt;div th:replace="header/header :: header"&gt;&lt;/div&gt; 这样Thymeleaf会去默认的resources/templates寻找header/header.html模板所以报错了。 解决办法：修改默认路径为resources/templates/html 12thymeleaf: prefix: classpath:/templates/html/ 以前的Controller也要改一下 1return "index"; 这样就可以愉快的写代码了^-^]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger常用注解与注意事项]]></title>
    <url>%2F2017%2F08%2F19%2Fswagger-annotation%2F</url>
    <content type="text"><![CDATA[1. 运行环境 接上一篇文章 SpringBoot集成Swagger生成在线API文档SpringBoot + Swagger2 + swagger-bootstrap-ui 我们这里的UI使用的是第三方的swagger-bootstrap-ui 难免有一些BUg但是不影响使用 2.常用注解 Api –类注解 ApiModel ApiModelProperty ApiOperation ApiParam ApiResponse ApiResponses ResponseHeader 3.注解使用案列▷ @Api 注解 该注解放在Controller类上用于描述一类接口，最终会在页面生成描述列表 属性名称 备注 value url的路径值，可写中文描述 tags 如果设置这个值、value的值会被覆盖 description 对api资源的描述 basePath 基本路径可以不配置 position 如果配置多个Api 想改变显示的顺序位置 produces For example, “application/json, application/xml” consumes For example, “application/json, application/xml” protocols Possible values: http, https, ws, wss. authorizations 高级特性认证时配置 hidden 配置为true 将在文档中隐藏 1234@Api(description = "/message",tags="Message消息相关接口")public class MessageContoller extends BaseContoller&#123; //省略&#125; 效果： ▷ @ApiOperation 注解 该注解放在Controller的方法上用于描述具体的接口 属性名称 备注 value url的路径值 ，可写中文描述 tags 如果设置这个值、value的值会被覆盖 description 对api资源的描述 basePath 基本路径可以不配置 position 如果配置多个Api 想改变显示的顺序位置 produces For example, “application/json, application/xml” consumes For example, “application/json, application/xml” protocols Possible values: http, https, ws, wss. authorizations 高级特性认证时配置 hidden 配置为true 将在文档中隐藏 response 返回的对象 responseContainer 这些对象是有效的 “List”, “Set” or “Map”.，其他无效 httpMethod “GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH” code http的状态码 默认 200 extensions 扩展属性 1234@ApiOperation(value = "/test", notes = "发送消息")public Map&lt;String, Object&gt; sendMessage()&#123;&#125; 效果： ▷ @ApiParam 注解 该注解用于描述参数 属性名称 备注 name 属性名称 value 属性值 defaultValue 默认属性值 allowableValues 可以不配置 required 是否属性必填 access 不过多描述 allowMultiple 默认为false hidden 隐藏该属性 example 举例子 123public String test(@ApiParam(value = "验证码",required = true) @RequestParam("code") int code,@ApiParam(value = "手机号",required = true) @RequestParam("phoneNumber") String phoneNumber,@ApiParam(value = "新密码",required = true) @RequestParam("newPassword") String newPassword) 这里需要注意一点：不知道是swagger-bootstrap-ui的 BUG 还是怎么的，如果只加 @ApiParam 不加@RequestParam注解，前台的接口测试会失效，接口测试时会将参数加入请求的body中而不是参数列表中，所以用了@ApiParam要加@RequestParam指定参数名，大多数时候我们还是用实体类接收参数，就不会出现这种情况 效果： ▷ @ApiModel 注解 该注解用于描述实体类，通常与@ApiModelProperty共用 | 1234@ApiModel("工单系统用户信息实体类")public class TicketUser &#123;&#125; ▷ @ApiModelProperty 注解 该注解用于描述实体类字段 123456789101112131415@ApiModel("工单系统用户信息实体类")public class TicketUser &#123; @ApiModelProperty("用户ID") private Integer user_id = 0; @ApiModelProperty("用户名，登录名") private String user_name = ""; @ApiModelProperty("密码") private String password = ""; @ApiModelProperty("有效表示（Y-有效，N-无效）") private String valid_status = ""; @ApiModelProperty("对应的通讯录ID") private Integer contact_id=0; //getter setter 省略 &#125; 效果： ▷ @ApiResponse注解 用于响应配置 属性名称 备注 code http的状态码 message 描述 response 默认响应类 Void reference 参考ApiOperation中配置 responseHeaders 参考 ResponseHeader 属性配置说明 responseContainer 参考ApiOperation中配置 12345678@RequestMapping(value = "/order", method = POST) @ApiOperation(value = "Place an order for a pet", response = Order.class) @ApiResponses(&#123; @ApiResponse(code = 400, message = "Invalid Order") &#125;) public ResponseEntity&lt;String&gt; placeOrder( @ApiParam(value = "order placed for purchasing the pet", required = true) Order order) &#123; storeData.add(order); return ok(""); &#125; 其他更多注解可以去参考官方文档]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Swagger生成在线API文档,并集成第三方UI]]></title>
    <url>%2F2017%2F08%2F18%2FSpringBoot_Swagger%2F</url>
    <content type="text"><![CDATA[1.前言 今年公司开始尝试前后端分离开发,以前都是前端人员写好静态页面，后端当做模板在后台进行渲染,或者干脆前后台都自己写，现在分离，java人员只提供RESTful的接口，页面交互由前端人员写，这样就会涉及到前后端人员的对接问题，为了提高对接效率，我们在项目中引入了Swagger生成API文档，辅助接口对接 2.Swagger介绍Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务可以根据后台代码上写的注释生成一个接口展示页面，同时还自带接口调试工具。就像这样： 上面是swagger官方UI，感觉不是很好看，可以自己写页面。若果嫌麻烦，网上大神已经写好了，我们现在使用的是swagger-bootstrap-ui，效果图如下： 感觉好看多了。swagger-bootstrap-ui项目地址 3.SpringBoot集成swagger和swagger-bootstrap-ui（1）Maven中加入依赖123456789101112131415161718192021222324252627282930313233&lt;!--swagger2支持--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--这是官方自带的UI--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--第三方swagger UI--&gt; &lt;dependency&gt; &lt;groupId&gt;com.drore.cloud&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; (2) SpringBoot中配置Swagger 方式一:采用默认配置,再启动类上加入@EnableSwagger2注解即可 123456789101112131415161718@SpringBootApplication@EnableSwagger2public class WebchatApplication extends SpringBootServletInitializer &#123; protected static Logger logger= LoggerFactory.getLogger(WebchatApplication.class); public static void main(String[] args) &#123; SpringApplication.run(WebchatApplication.class, args); logger.info("微信管理平台启动成功"); &#125;&#125; 现在可以访问：http://localhost:8080/项目地址/swagger-ui.html看效果了 方式二：默认配置缺少一些项目描述和权限的配置，可以采用javaConfig的方式做个性化配置1.新建一个配置类SwaggerConf2.代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Swagger配置类 */@Configuration@EnableSwagger2@ComponentScan(basePackages = &#123;"com.qq.controller"&#125;)//controller包路径public class SwaggerConfig &#123; @Bean public Docket Api() &#123; return new Docket(DocumentationType.SWAGGER_2)// .groupName("Pro")// .genericModelSubstitutes(DeferredResult.class)// .genericModelSubstitutes(ResponseEntity.class)// .useDefaultResponseMessages(false)// .forCodeGeneration(true)// .pathMapping("/")// base，最终调用接口后会和paths拼接在一起 .select() .apis(getPredicate()) .paths(PathSelectors.any())// .paths(or(regex("/api/.*")))//过滤的接口 .build()// .securitySchemes(securitySchemes())// .securityContexts(securityContexts()) .apiInfo(setInfo()); &#125; /** * 设置系统信息 * @return */ public ApiInfo setInfo()&#123; return new ApiInfoBuilder() .title("&lt;b&gt;管理平台API接口文档&lt;/b&gt;")//大标题 .description("（1）方便前后端分离后，前端人员与后端人员的对接。&lt;br/&gt;（2）同时集成接口测试工具，方便后端测试接口&lt;br/&gt;&lt;span style='color:red'&gt;（3）后端人员务必采用Swagger注解写好各接口的描述。&lt;/span&gt;")//详细描述 .version("1.0")//版本 .termsOfServiceUrl("NO terms of service") .contact(new Contact("lyq", "http://blog.lyq3.com", "99190092@qq.com"))//作者 .license("The Apache License, Version 2.0") .licenseUrl("http://www.apache.org/licenses/LICENSE-2.0.html") .build(); &#125; /** * 获取API过滤器 * 指定需要生成文档的接口 * @return */ public Predicate&lt;RequestHandler&gt; getPredicate()&#123; Predicate&lt;RequestHandler&gt; predicate = new Predicate&lt;RequestHandler&gt;()&#123; public boolean apply(RequestHandler input) &#123; Class&lt;?&gt; declaringClass = input.declaringClass(); if (declaringClass == BasicErrorController.class)// 排除 return false; if(declaringClass.isAnnotationPresent(RestController.class)) // 被注解的类 return true; if(input.isAnnotatedWith(ResponseBody.class)) // 被注解的方法 return true; return false; &#125; &#125;; return predicate; &#125;&#125; 现在可以访问：http://localhost:8080/项目地址/swagger-ui.html看效果了 4.Swagger 注解的使用 配置完成后可以打开页面，也能看到接口，但是缺少接口的具体描述，比如：某个参数到底有什么作用，返回值代表什么的一系列描述是没有的，这就需要我们用Swagger提供的注解描述每一个接口和参数、返回值、状态码等 Swagger注解是重点，单开一篇来讲注解的使用和采坑记]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重写JQuery的Ajax请求实现公用功能，如：权限判断]]></title>
    <url>%2F2017%2F08%2F17%2FreAjax%2F</url>
    <content type="text"><![CDATA[1.前言 我们做JAVA开发的，管理系统做的比较多，管理系统大多都有一个特点：单页面应用SPA(Single Page Application),单页面程序就会用很多的Ajax异步请求后台查询数据，为了用户体验，我们都会在发送请求的时候加载一个Loding..提示层 又或者是用户掉线了，点击发送请求时会跳回到登录页面重新登录等等，一系列在发送请求时都要做的事情可以重写ajax实现每次发送ajax请求都将执行公用方法 2.重写Ajax 新建reAjax.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$(function()&#123; var layer;//layer弹窗插件，用于页面提示 var index; layui.use('layer', function()&#123; layer= layui.layer; &#125;); (function($)&#123; //首先备份下jquery的ajax方法 var _ajax=$.ajax; //重写jquery的ajax方法 $.ajax=function(opt)&#123; //备份opt中error和success方法 var fn = &#123; error:function(XMLHttpRequest, textStatus, errorThrown)&#123;&#125;, success:function(data, textStatus)&#123;&#125; &#125; if(opt.error)&#123; fn.error=opt.error; &#125; if(opt.success)&#123; fn.success=opt.success; &#125; //扩展增强处理 var _opt = $.extend(opt,&#123; error:function(XMLHttpRequest, textStatus, errorThrown)&#123; //错误方法增强处理 layer.alert('连接服务器失败，请稍后重试！') fn.error(XMLHttpRequest, textStatus, errorThrown); &#125;, success:function(data, textStatus)&#123; if(data.code == 888)&#123; layer.alert('未登录，请重新登录！',function()&#123; window.location.href='/login.html'; &#125;); return false; &#125; if(data.code == 666)&#123; layer.alert('无权限访问！'); return false; &#125; //成功回调方法增强处理 fn.success(data, textStatus); &#125;, beforeSend:function(XHR)&#123; //提交前回调方法 index = layer.load(0); &#125;, complete:function(XHR, TS)&#123; //请求完成后回调函数 (请求成功或失败之后均调用)。 layer.close(index); &#125; &#125;); return _ajax(_opt) &#125;; &#125;)(jQuery);&#125;); 传统页面直接引入该js就行，缺点是每个页面都要引一次 如果用的webpack打包：直接加入依赖即可 12345678910111213resolve:&#123; alias: &#123; avalon2: path.resolve(PATHS.node_modulesPath, "avalon2/dist/avalon.js"), //ueditor: path.resolve(PATHS.node_modulesPath, "ueditor/example/public/ueditor"), bootstrap: path.resolve(PATHS.node_modulesPath, 'bootstrap/dist'), jquery: path.resolve(PATHS.libPath, 'jquery-1.12.4.js'), //这里全局引入即可 reAjax: path.resolve(PATHS.libPath, 'reAjax.js'), mmRouter: path.resolve(PATHS.node_modulesPath, "mmRouter/dist/mmRouter.js") &#125;, modules: [path.resolve(__dirname, "src/static/lib"), "node_modules", "src/tpl"] &#125;, ...]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 中类初始化，构造方法，静态成员变量，静态块的加载顺序]]></title>
    <url>%2F2017%2F08%2F14%2FjavaLoadorder%2F</url>
    <content type="text"><![CDATA[1、编译和运行概念要搞清：编译即javac的过程，负责将.java文件compile成.class文件，主要是类型、格式检查与编译成字节码文件，而加载是指java *的过程，将.class文件加载到内存中去解释执行，即运行的时候才会有加载一说。 2、类的加载时机，肯定是在运行时，但并不是一次性全部加载，而是按需动态，依靠反射来实现动态加载，一般来说一个class只会被加载一次，之后就会从jvm的class实例的缓存中获取，谁用谁取就可以了，不会再去文件系统中加载.class文件了。java虚拟机规范虽然没有强制性约束在什么时候开始类加载过程，但是对于类的初始化，虚拟机规范则严格规定了有且只有四种情况必须立即对类进行初始化，遇到new、getStatic、putStatic或invokeStatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的java代码场景是： 1）使用new关键字实例化对象 2）读取一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外） 3）设置一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外） 4）调用一个类的静态方法 简单来说就是第一次使用一个类时。 初始化一个类的执行顺序： 如果类还没有被加载：1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。2、执行子类的静态代码块和静态变量初始化。3、执行父类的实例变量初始化（例如：int a;初始化就是0，引用类型就是null）4、执行父类的构造函数5、执行子类的实例变量初始化（例如：int a;初始化就是0，引用类型就是null）6、执行子类的构造函数如果类已经被加载：则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。 验证： 123456789101112131415161718192021222324252627282930public class StaticTest &#123; public static void main(String[] args) &#123; new Abc(); &#125;&#125;class Abc&#123; public static Bcd i = new Bcd(); static&#123; int b = 2; System.out.println(&quot;=====静态块======&quot;); &#125; Abc()&#123; System.out.println(&quot;======构造方法=========&quot;); &#125; public static void c()&#123; System.out.println(&quot;==========静态方法===========&quot;); &#125;&#125;class Bcd&#123; Bcd()&#123; System.out.println(&quot;======静态成员变量========&quot;); &#125;&#125; 执行结果：]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java方法的重载与特殊情况]]></title>
    <url>%2F2017%2F08%2F14%2Fjava_overload%2F</url>
    <content type="text"><![CDATA[方法重载，通过方法的签名（方法名+参数列表）识别，特殊情况除外， 特殊情况：（1.6以后编译不通过，应该是官方修复了，方法重载还是只能靠方法签名） 1234567public int test(List&lt;Integer&gt; list)&#123; return 1; &#125; public String test(List&lt;String&gt; list)&#123; return &quot;&quot;; &#125; 【java代码中，函数的特征签名仅仅包括方法名称、参数类型以及参数顺序。但在字节码中，特征签名还包括了方法的返回值以及受查异常表，这就是为什么在class文件中，其他都相同仅仅返回值不同的两个方法能共存的原因】 ==============上面特殊情况1。6后作废============ 主类型的过载: 主（数据）类型能从一个“较小”的类型自动转变成一个“较大”的类型。例如： 1234567public void abc(long tem)&#123; System.out.println(tem); &#125;//下面调用传入int值会自动转换，小转大 abc(5);//char 获得的效果稍有些不同，这是由于假期它没有发现一个准确的char 匹//配，就会转型为int 若我们的自变量“大于”过载方法期望的自变量，这时又会出现什么情况呢？ 这里是大转小，不能自动转，所以会报错，传参的时候要手动强转才行]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识HTTP，区分URI 、URL 、URN]]></title>
    <url>%2F2017%2F08%2F14%2Fhttp_url_uri_urn%2F</url>
    <content type="text"><![CDATA[1、认识HttpHTTP是一种网络传输协议即超文本传输协议（还有其他文件传输协议FTP、邮件传输协议SMTP等），就是大家讲好规矩，都按这个规矩来，有序规范，并保证数据传输的稳定性与完整性。HTTP协议底层基于TCP/IP协议，利用TCP/IP创建连接并传输数据，HTTP位于TCP/IP 上层，如下图： 2、资源我们每天上网实际上就是在访问服务器上存放的资源，一个网页，一张jpg图片，一部avi视频等等都是web资源，但资源并非一定是静态文件，也可以是其他动态的数据，比如通过传递不同的参数而返回不同的数据。 3、媒体类型MIME网上有数千种不同的数据类型，jpg、html、mp4等等，在传输这些数据时HTTP都要为传输的对象打上名为MIME类型（MIME type）的数据格式标签。 html格式的文档就用text/html标记 jpeg格式的图片就用image/jpeg标记 gif格式图片就用image/gif标记常见的MIME类型有数百个，实验性或特殊用途的MIME类型更多 4、UＲI、URL、URN的联系与区别资源是放在服务器上的，那么我们怎么样才能访问到指定的资源呢？我们要对资源进行标识，通过这个唯一的标识就能找到资源。这个唯一的标识就被称为统一资源标识符（也就是URI） 通常标识有两种标识方式，一种是通过唯一的路径标识，通过标识服务器位置和资源在服务器上的位置就能对资源进行唯一的标识，这个叫做统一资源定位符（也就是URL）还有一种标识方式是通过唯一的名称来表示，这个叫做统一资源名（也就是URN）。也可以简单将URL和URN理解成URI的子集，目前大部分是URL]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>TCP\IP</tag>
      </tags>
  </entry>
</search>
